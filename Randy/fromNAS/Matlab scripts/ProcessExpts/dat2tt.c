/* dat2tt.c	(Randy Bruno, June 2000)
 *
 * converts a Labview .dat file generated by tetrode.vi
 * into the .tt file format used by DataWave, XClust, and MClust
 *
 * This .MEX program is intended to be called from MATLAB.
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "iolib.h"
#include "mex.h"
#include <time.h>

/* Input Arguments */

#define	INNAME		prhs[0]
#define OUTNAME1	prhs[1]
#define OUTNAME2	prhs[2]
#define	NCHAN		prhs[3]
#define SIGN		prhs[4]

/* Other Constants */

#define True	1
#define False	0
#define Pi	3.14159
#define MAXLINE 1000

/* Pauses for a specified number of milliseconds. */
void sleep( clock_t wait ){
   clock_t goal;
   goal = wait + clock();
   while( goal > clock() )      ;}

void BeginStandardHeader(FILE *fpout)
{
    fprintf(fpout,"%s\n", MAGIC_SOH_STR);
} 

void EndStandardHeader(FILE *fpout)
{
    fprintf(fpout,"%s\n", MAGIC_EOH_STR);
}

char **ReadHeader(fp,headersize)
FILE	*fp;
int	*headersize;
{
int	hasheader;
char	line[MAXLINE];
long	start;
char	**header_contents;
char	**new_header_contents;
int	nheaderlines;
int	done;
int	status;
int	eol;

    if(fp == NULL) return(NULL);
    if(headersize == NULL) return(NULL);
    hasheader = 1;
    nheaderlines = 0;
    header_contents = NULL;
    done = 0;
    /*
    ** determine the starting file position
    */
    start = ftell(fp);
    /*
    ** look for the magic start-of-header string
    */
    if(fread(line,sizeof(char),MAGIC_SOH_STRSIZE,fp) != MAGIC_SOH_STRSIZE){
	/*
	** unable to read the header
	*/
	hasheader = 0;
    } else {
	/*
	** null terminate the string
	*/
	line[MAGIC_SOH_STRSIZE-1] = '\0';
	/*
	** is it the magic start of header string?
	*/
	if((status = strcmp(line,MAGIC_SOH_STR)) != 0){
	    /*
	    ** not the magic string
	    */
	    hasheader = 0;
	} 
    }
    if(!hasheader){
	/*
	** no header was found so reset the file position to its starting
	** location
	*/
	fseek(fp,start,0L);
    } else
    /*
    ** read the header
    */
    while(!done && !feof(fp)){	
	/*
	** read in a line from the header
	*/
	if(fgets(line,MAXLINE,fp) == NULL){
	    /*
	    ** unable to read the header
	    */
	    fprintf(stderr,"ERROR in file header. Abnormal termination\n");
	    exit(-1);
	}
	/*
	** zap the CR
	*/
	if((eol = strlen(line)-1) >= 0){
	    line[eol] = '\0';
	}
	/*
	** look for the magic end-of-header string
	*/
	if(strcmp(line,MAGIC_EOH_STR) == 0){
	    /*
	    ** done
	    */
	    done = 1;
	} else {
	    /*
	    ** add the string to the list of header contents
	    ** by reallocating space for the header list
	    ** (dont forget the NULL entry at the end of
	    ** the list)
	    */
	    if(header_contents == NULL){
		if((header_contents = (char **)malloc(sizeof(char *)*2)) ==
		NULL){
		    fprintf(stderr,"initial malloc failed. Out of memory\n");
		    break;
		}
	    } else {
		if((new_header_contents = (char **)calloc(
		nheaderlines+2,sizeof(char *))) == NULL){
		    fprintf(stderr,"realloc failed. Out of memory\n");
		    break;
		}
		/*
		** copy the previous contents
		*/
		bcopy(header_contents,new_header_contents,(sizeof(char*)*(nheaderlines +1)));
		/*
		** and free the old stuff
		*/
		free(header_contents);
		/*
		** and reassign to the new stuff
		*/
		header_contents = new_header_contents;
#ifdef OLD
		if((header_contents = (char **)realloc(header_contents,
		sizeof(char *)*(nheaderlines+2))) == NULL){
		    fprintf(stderr,"realloc failed. Out of memory\n");
		    break;
		}
#endif
	    }
	    if((header_contents[nheaderlines] = 
	    (char *)malloc((strlen(line)+1)*sizeof(char))) == NULL){
		    fprintf(stderr,"malloc failed. Out of memory\n");
		    break;
	    }
	    strcpy(header_contents[nheaderlines],line);
	    header_contents[nheaderlines+1] = NULL;
	    nheaderlines++;
	}
    }
    /*
    ** report the headersize by comparing the current position with
    ** the starting position
    */
    *headersize = ftell(fp) - start;
    return(header_contents);
}

char *GetString(void *ptr)
{
	int buflen, status;
	char *buffer;

	buflen = (mxGetM(ptr) * mxGetN(ptr)) + 1;
	buffer = mxCalloc(buflen, sizeof(char));
	status = mxGetString(ptr, buffer, buflen);
	if (status) mexWarnMsgTxt("mxGetString error");
	return(buffer);
}

void ReverseByteOrder(char *src, char *dst, int n)
{
	/* Converts back and forth between Big- and Little-Endian byte orders */

	int i;

	for (i=0; i<n; i++)
		dst[n-i-1] = src[i];
}

Convert(char *infile_name, char *outfile1_name, char *outfile2_name, int nchan, int sign)
{
  FILE	*infile, *outfile1, *outfile2;
  int	header_size;
  char	**header;
  unsigned long	datapoint, timestamp=0, ul;
  int	j, n, size;
  short	amp, ramp;
  float	famp;
  float maxfamp = 0;
  fpos_t pos;

  signed long  trial, sl;
  float stim, fl;
  
  infile = fopen(infile_name, "rb");
	  if(!infile)
	    {
	      printf("Cannot open input file '%s'.\n", infile_name);
	      exit(-1);
	    }
  outfile1 = fopen(outfile1_name, "wb");
	  if(!outfile1)
	    {
	      printf("Cannot open lv output file '%s'.\n", outfile1_name);
	      exit(-1);
	    }
  outfile2 = fopen(outfile2_name, "wb");
	  if(!outfile2)
	    {
	      printf("Cannot open tt output file '%s'.\n", outfile2_name);
	      exit(-1);
	    }
	  if (sign == -1) printf("inverting\n");
	  else if (sign != 1)
	  {
		  printf("sign parameter must be 1 or -1\n");
		  sleep(2000);
		  exit(-1);
	  }

  /* Determine max signal value to calculate a scaling factor
	 that will maximize use of integer range */
  header = ReadHeader(infile, &header_size);
  while(fread(&ul, sizeof(unsigned long), 1, infile))
    {
      fread(&sl, sizeof(signed long), 1, infile);
      fread(&fl, sizeof(float), 1, infile);

      for(j=0; j<128; j++)
		{
		if (j%4 < nchan) {
			size = fread(&fl, sizeof(float), 1, infile);
			/* convert big-endian (Sun) to little-endian (PC) */
			ReverseByteOrder(&fl, &famp, sizeof(fl));
			if (size != 1) printf("read error\n");
			if (fabs(famp) > maxfamp) maxfamp = fabs(famp);
		}
	  }
	}
  fclose(infile);

  /* Reopen input file */
  infile = fopen(infile_name, "rb");
  header = ReadHeader(infile, &header_size);

  BeginStandardHeader(outfile1);
  fprintf(outfile1, "%% File type:\tBinary\n");
  fprintf(outfile1, "%% Extraction type:\ttetrode waveforms\n");
  EndStandardHeader(outfile1);

  BeginStandardHeader(outfile2);
  fprintf(outfile2, "%% File type:\tBinary\n");
  fprintf(outfile2, "%% Extraction type:\ttetrode waveforms\n");
  EndStandardHeader(outfile2);

  n = 0;
  
  /* read labview files */
  while(fread(&ul, sizeof(unsigned long), 1, infile))
    {
	  /* convert big-endian (Sun) to little-endian (PC) */
	  ReverseByteOrder(&ul, &datapoint, sizeof(ul));
      timestamp = ((long double) datapoint) * 0.3125;
      fwrite(&timestamp, sizeof(unsigned long), 1, outfile1);

	  /* convert back to big-endian */
	  ReverseByteOrder(&timestamp, &ul, sizeof(ul));
      fwrite(&ul, sizeof(unsigned long), 1, outfile2);

      fread(&sl, sizeof(signed long), 1, infile);
	  /* convert big-endian (Sun) to little-endian (PC) */
	  ReverseByteOrder(&sl, &trial, sizeof(sl));
      fwrite(&trial, sizeof(signed long), 1, outfile1);

      fread(&fl, sizeof(float), 1, infile);
	  /* convert big-endian (Sun) to little-endian (PC) */
	  ReverseByteOrder(&fl, &stim, sizeof(fl));
      fwrite(&stim, sizeof(float), 1, outfile1);

/*		printf("%lu\t%d\t%d\n", ul, trial, stim); */

      for(j=0; j<128; j++)
		{

		if (j%4 < nchan) {
			size = fread(&fl, sizeof(float), 1, infile);
			/* convert big-endian (Sun) to little-endian (PC) */
			ReverseByteOrder(&fl, &famp, sizeof(fl));
			famp = sign * famp;
			if (size != 1) printf("read error: recno = %d, size = %d\n", n, size);
			amp = 2020*(famp/maxfamp); }
		else {
			amp = 100; }

		fwrite(&amp, sizeof(short), 1, outfile1);
		/* convert back to big-endian */
		ReverseByteOrder(&amp, &ramp, sizeof(amp));
		fwrite(&ramp, sizeof(ramp), 1, outfile2);
		}
	
		n++;
	}
  /*  end read labview files */

  printf("N: %d\n", n);
  printf("maxfamp: %f\n", maxfamp);
  
  fclose(infile);
  fclose(outfile1);
  fclose(outfile2);
}

void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray*prhs[] )
{ 
	char *infile_name, *outfile1_name, *outfile2_name;
	int nchan, sign;
    
    /* Check for proper number of arguments */
    
    if (nrhs != 5) { 
	mexErrMsgTxt("5 input arguments required."); 
    } else if (nlhs != 0) {
	mexErrMsgTxt("0 output arguments required."); 
    } 
    
    /* Assign values/pointers to the various parameters */ 
	infile_name = GetString(INNAME);
	outfile1_name = GetString(OUTNAME1);
    outfile2_name = GetString(OUTNAME2);
	nchan = mxGetScalar(NCHAN);
	sign = mxGetScalar(SIGN);

	/* Do the actual computations in a subroutine */
	Convert(infile_name, outfile1_name, outfile2_name, nchan, sign);

    return;
}

void main()
{
	Convert("000517-01-thl.dat", "a.lv", "a.tt", 1, 1);
}
