function [uptrial, uptime, uplength, downlength, onslope, offslope] = MAUDS_interval_RB3(filepath, duration, interval, winstart, winend, trialstart, trialend)

% Detect up states using moving averages of short intervals of Vm.
%
% INPUTS
% filepath: path to a continuous file generated by ntrode.vi
% duration: record duration in msecs
% interval: discretization interval in msecs for calculating short
% exponentially-weighted moving average...keep it around 50ms
% winstart: start of period to evaluate in msecs (e.g., for avoiding
% initial series resistance monitoring pulse)
% winend: end of period to evaluate
% trialstart: first trial to evaluate
% trialend: last trial to evaluate
%
% Christine Constantinople, August 2010
% modified by RMB, October 2010

if (nargin == 0)
    [filename pathname OK] = uigetfile('*.dat', 'Select continuous signal file');
    if (~OK) return; end
    filepath = [pathname, filename];
end

if nargin < 7 %if the user doesn't put in all the parameters, here are the default values
    answers = inputdlg({'duration (ms)', 'interval (ms)', 'window start (ms)', 'window end (ms)', 'trial start', 'trial end'}, ...
        'Parameters', 1, {'30000', '100', '250', '30000', '0', '1000'});
    duration = str2num(answers{1});
    interval = str2num(answers{2});
    winstart = str2num(answers{3});
    winend = str2num(answers{4});
    trialstart = str2num(answers{5});
    trialend = str2num(answers{6});
end

SLOPEWINDOWMS = 25;
DECIMATEBY = 16;
SCALINGFACTOR = 100;
SAMPLERATE = 32000; % in Hz
SAMPLESPERMS = SAMPLERATE / 1000;
nScans = SAMPLERATE * (duration / 1000);
X = linspace(0, duration, nScans);
X = decimate(X, DECIMATEBY);

nRecs = GetNumberOfRecords(filepath, duration);
if trialend > nRecs
    trialend = nRecs-1;
end

disp(filepath);
fid = fopen(filepath, 'r', 'b');
headerSize = SkipHeader(fid);

uptrial = [];
uptime = [];
uplength = [];
downtrial = [];
downtime = [];
downlength = [];
onslope = [];
offslope = [];

%% determine data structure size needed
[stimcode, signal] = GetRecord(fid, headerSize, duration, 0);
signal = decimate(signal, DECIMATEBY);
signal = signal(X >= winstart & X <= winend);
signalScans = length(signal);
% allocate memory for all traces (without pulse)
alltraces = zeros(signalScans, trialend-trialstart+1);

%% read in data
for i = trialstart:trialend
    [stimcode, signal] = GetRecord(fid, headerSize, duration, i);
    signal = decimate(signal, DECIMATEBY);
    signal = signal(X >= winstart & X <= winend);
    signal = signal * SCALINGFACTOR;
    alltraces(:, i-trialstart+1) = signal;
end
fclose(fid);

LMA = signal; %% set correct length
SMA = signal;
blah = signal;

%% now run MAUDS
h = figure;
interval = interval * SAMPLESPERMS / DECIMATEBY;
Lalpha = (interval*100) / (interval*100 + 1);
Salpha = interval / (interval + 1);
last = -1;
for i = trialstart:trialend
    
    winsignal = alltraces(:, i-trialstart+1);
    minWinSignal = min(winsignal);

    % calculate moving averages
    for j = 1:length(winsignal)
        if j==1
            if i == trialstart
                % first trial, first data point of trial
                LMA(1) = mean(alltraces(:,1));  % seed values for moving averages
                SMA(1) = alltraces(1,1);
            else
                % subsequent trials, first data point of trial
                LMA(1) = Lalpha*LMA(end) + (1-Lalpha) * winsignal(j);
                SMA(1) = Salpha*SMA(end) + (1-Salpha) * winsignal(j);
            end
        else
            % all datapoints after first datapoint
            LMA(j) = Lalpha * LMA(j-1) + (1-Lalpha) * winsignal(j);
            SMA(j) = Salpha * SMA(j-1) + (1-Salpha) * winsignal(j);
        end
        
        if j > 1 ...
                && ( (last == 1 && uplength(end) > (500 * SAMPLESPERMS / DECIMATEBY)) ...
                      || (last == 0 && downlength(end) > (500 * SAMPLESPERMS / DECIMATEBY)))
            % if still in some up/down state > 500-ms long, don't adjust
            % long moving average (resist persistent activity, deep anesthesia)
            LMA(j) = LMA(j-1);
        end
        
        % if slow moving average is bigger than longer...
        if SMA(j) > LMA(j)
            % ...classify as up state
            if last ~= 1
                % last datapoint was classified differently, this is a new
                % up state
                last = 1;
                uptrial = [uptrial; i]; % record trial
                uptime = [uptime; winstart+(j-1)*interval]; % record start time
                uplength = [uplength; 1]; % start counting length
                onslope = [onslope; UpDownSlope(winsignal, j, SLOPEWINDOWMS*SAMPLESPERMS/DECIMATEBY)];
            else
                % last datapoint was part of same up state, so increment
                % length
                uplength(end) = uplength(end)+1;
            end
            upplot(j) = minWinSignal;
            downplot(j) = NaN;
        else
            % ...classify as down state
            if last ~= 0
                % last datapoint was classified differently, this is a new
                % down state
                last = 0;
                downtrial = [downtrial; i]; % record trial
                downtime = [downtime; winstart+(j-1)*interval]; % record start time
                downlength = [downlength; 1]; % start counting length
                offslope = [offslope; UpDownSlope(winsignal, j, SLOPEWINDOWMS*SAMPLESPERMS/DECIMATEBY)];
            else
                % last datapoint was part of same down state, so increment
                % length
                downlength(end) = downlength(end)+1;
            end
            upplot(j) = NaN;
            downplot(j) = minWinSignal;
        end
    end
    
    plot(X(X >= winstart & X <= winend), winsignal);
    hold on;
    xlim([winstart winend]);
    box off;
    title(['record # ' num2str(i)]);
    plot(X(X >= winstart & X <= winend), upplot, 'r');
    plot(X(X >= winstart & X <= winend), downplot-2, 'b');
    plot(X(X >= winstart & X <= winend), LMA, 'g');
    plot(X(X >= winstart & X <= winend), SMA, 'r');
    hold off;
    drawnow;
    
%     pause(2);
end
close(h);

%% convert decimated scan indices back to msec
uptime = uptime / (SAMPLESPERMS / DECIMATEBY);
uplength = uplength / (SAMPLESPERMS / DECIMATEBY);
downtime = downtime / (SAMPLESPERMS / DECIMATEBY);
downlength = downlength / (SAMPLESPERMS / DECIMATEBY);
onslope = onslope * (SAMPLESPERMS / DECIMATEBY);
offslope = offslope * (SAMPLESPERMS / DECIMATEBY);

%excludes transient Vm excursions less than 50ms
onslope(uplength < 50) = NaN;
offslope(downlength < 50) = NaN;
uplength(uplength < 50) = NaN;
downlength(downlength < 50) = NaN;
